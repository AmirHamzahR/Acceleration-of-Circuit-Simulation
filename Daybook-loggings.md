# Developer's Logging for project's Daybook

## 21/9/2022

Today, I have learned and researched a few KLU libraries that would be useful to be used for the overall project. I have also asked my supervisor if the KLU libraries that
were discovered would be a good resource for the project.

## 22/9/2022

Some resources from [learncpp](https://www.learncpp.com/) was studied more thoroughly to improve my understandings on the latest C++ 20. Currently, I was trying to understand more how scope, duration and linkages work in the C++20 syntax. One important thing that was gained is that the nesting's maximum level should always be 3 for compound statements.

## 23/9/2022

I continued learning more on [learncpp](https://www.learncpp.com/) for declarations and inline functions. The _consteval_ specifier can only be used if the function mostly runs on compile-time for performance, however it cannot be evaluated at runtime. For today, some changes on the Gantt Chart was made as the transient simulation was not achieved.

## 26/9/2022

My supervisor had advised to use the Armadillo library as a start for the project. I have started to test out the Armadillo library in VScode for C++. I have ran the code from [solarianprogrammer.com](https://solarianprogrammer.com/2017/03/24/getting-started-armadillo-cpp-linear-algebra-windows-mac-linux/) to test out the Armadillo library. The results are shown below:

![](circuit_test/C++/Arma_test1.png)

The code ran perfectly with the 4x4 A matrix being generated by some random numbers and then being transposed. Then, the rows 1 and 3 are added while filling the 4th column with zeros. The B matrix is just the diagonal upmost left towards right of the A matrix while the other elements are filled with zero. This is called the diagonal matrix of A.

Tomorrow, I am planning to understand [arma sourceforge documents](http://arma.sourceforge.net/docs.html#example_prog) more while translating some LU decomposition and Newton Raphson iterations from MATLAB to C++.

## 27/9/2022

I have managed to create a code that test the LU decomposition and "solve' function from Armadillo library to solve x in Ax = b matrix equation.
The code runs well and could differentiate the lower and upper triangle of the matrix A. However, LU decomposition could not yet be used to solve the matrix equation. The results of the code is shown below:

![](circuit_test/C++/LUdecomp_t1.png)

## 28/9/2022

A new method of solving the matrix equation using LU decomposition can now be used. This involves the usage of the "solve" function.

## 30/9/2022

Currently, the priority has been shifted back into developing a transient simulation using MATLAB rather than learning how to create one in C++.
I have found a method in creating transient simulation using Newton Raphson, Backward-Euler integration, and LU decomposition in MATLAB.

I am trying to create a newton Raphson algorithm in MATLAB that uses the Jacobian matrix method. The method worked and matrix functions could be solved. I am planning to integrate the newton Raphson Jacobian solver with the Euler backward method for transient simulation.

## 5/10/2022

The integration between Newton Raphson using Jacobian matrix solver has been finished and could be run properly. The results from the transient simulation were compared between the two languages which were MATLAB and Python. 

THe code simulates an RLC circuit with the variables being, R is 1 ohm, L is 1.5H, and C being 0.0001F of a total 0.5s with n = 500 iterations and h = 0.001s time steps. The MATLAB code uses both backward and forward Euler integration while solving the values for capacitor voltage and current voltage. After simulating, the forward and backward Euler for the current values over time can be seen to be: 

![](circuit_test/matlab/RLC_eulersim.png)

There is a noticeable difference between the two methods due to the time step being quite huge. This is due to the nature of the assumption of Euler's backward and forward integration which has an error of O(n^2). In order to have a more accurate result, the time steps will be smaller while the number of iterations is increased. This is by setting h = 0.0001 and N = 50000. The results are shown below:

![](circuit_test/matlab/Accurate_eulersim.png)

Simulation in python for the correct transient analysis will be done next.

## 6/10/2022 

A python code has been made by solving both the function and jacobian matrices using matmul function from the numpy library. By using the same RLC circuit variables and arrangements, the results of the code simulation could be seen to be:

![](circuit_test/Python/NR_simpleRLC_50k.png)

The red line shows the current of the capacitor while the blue line shows the voltage of the capacitor. For a more detailed analysis of the current, this can be done by zooming in which shows:

![](circuit_test/Python/Zoomed_NR_simpleRLC.png)

It can be seen that it is similar to the MATLAB results which means that the Newton-Raphson using Jacobian matrix solver is accurate. However, it took the python program to run longer than the MATLAB program. Some changes will be done in the Transient_Test.py code, could be due to the log.message and print statement for the solved values. The time module from [pynative](https://pynative.com/python-get-execution-time-of-program/) will be used to analyse the amount of time taken for the code to execute the simulation.

The total execution time of the code with log.message is 165.326205 seconds. However, without the log.message and print statements in the loop, the total execution time of the code is only 14.2928447 seconds. This proves that my theory is correct and the log.message with print statements will be commented out for performance purposes.

To confirm this analysis is correct, a transient simulation using LTSpice and ngspice will be done.

## 7/10/2022

My supervisor had checked my code and commented that it should be more generic as bigger and more complex circuits will be analysed. A suggestion is that V_pulse for the voltage source should be added for the transient analysis code since currently it only simulates the steady state analysis. The code should also contain matrices as input for the project compared to using normal function variables.

## 10/10/2022

Today, I am trying to make a pseudocode that could relate both the code that I have made which uses transient simulation with the modified nodal analysis using LU decomposition. As found from this [lecture](https://pages.mtu.edu/~zhuofeng/EE5780Fall2013_files/Lecture_07_SpiceSimulation.pdf), the component values should start with MNA stamps as a good foundation in creating the circuit matrix. From this, the code should be changed from using hard-coded nodal equations into using MNA matrices derived from the nodal equations and MNA stamps.

The target size for the circuit simulation should consist of 5x5 matrix for the simple circuit.

## 11/10/2022

A generic code for a simple 5x5 matrix linear circuit has been made! The MNA stamps for resistor and current sources has been added and was successfully analysed with a simple circuit. The  circuit that was used was from the lecture [ECSE 597 Circuit Simulation and Modelling](https://www.youtube.com/watch?v=Eh3KzhcnpWw&list=PLlsTHbFeR7v0QG8Q4l6oc7d---eKKSKTz&index=2) that explains about MNA stamps. 

The python code has been added into the repository for supervisor's comment and further improvement in making it even more generic and efficient. The results of the linear circuit analysis from the python code is the same with the LTSpice OP analysis. The comparison between the two is shown below:

Python:
![](circuit_test/Python/Linear_test1.png)
LTspice:
![](circuit_test/Python/linear_test1_lts.png)

The orderings are seem to be different due to different naming convention on the LTspice models but the results are the same nonetheless. Tomorrow, I will simulate 2 more linear circuit from this code and then move on towards non-linear circuits. I will also try to add more components to be simulated for (eg. capacitor, voltage source, inductor)

## 12/10/2022

A comparison between the speed of my own plu_solver function with numpy's linalg.solve function has been made. The comparison was made using python's time library. Both seems to have a similar speed by which the linalg.solve is around 0.001-0.003 seconds while my plu_solver function is around 0.001-0.003 too.

The effort in making the code more generic is currently focused on how to ensure that the size of the matrix is not hardcoded. An improvement has been made as the size of the matrix could be seen to be depending on the total number of nodes and voltage sources. Thus, the size of the matrix is now depending on that rather than being hardcoded. This makes the circuit simulator a step closer as its ancestor, ngspice.

The code can now simulate any linear resistive networks with voltage sources, resistors and current sources. I have added a few functions which could manage the matrices properly. The tests of accuracy for the code was made using LTSpice and the results are shown below:

Python: 
![](circuit_test/Python/Added_VS.png)
LTSpice:
![](circuit_test/Python/linear_test2_lts.png)

The values before this run were all negative with the same magnitude, which was a bit weird. I later found that my code actually has opposite direction of the nodes which I then changed and received the 100% accuracy of the simulation. The next step is to add non-linear components and variables, maybe a diode and see how it will serve. An idea of expansion is trying to get the user input which will drastically become more similar to a SPICE simulator.

## 13/10/2022

The 4th week meeting with supervisor was done. Dr Danial gave really good insights in future prospects and suggestions on improving the recent circuit matrices code. One of the suggestions is to add in the dynamic elements first rather than adding non-linear components as that will be the key for the transient simulation. If that is finished, the future prospect of the python script is then to add non-linear components and VCCS or ICCS sources. These will then open the window on making a random circuit generator with the goal of randomizing a 20 by 20 circuit matrix. 

## 17/10/2022

The goal for today is to add in dynamic elements inside the circuit such as capacitors and inductors. At the same time, pulse voltage source will also be added since it varies with time (time-variant sources). The variables will be analysed using Newton-Raphson solver for the iterations. In the Newton-Raphson solver, the Jacobian matrix will be used to test the matrices. As for now, the voltage source and current source that will added are the independent ones. 

## 18/10/2022

The dynamic elements were a bit hard to be added due to the Newton-Raphson Jacobian matrix solver is still using hard-coded functions. I have found a method of making the Jacobian matrix more generic and less hard-coded. The Jacobian matrix is actually just another set of conductance or dynamic element matrix, so this can be applied using MNA to get the Jacobian matrix. Since most of the methods of using Jacobian matrices are dependent on the functions of the nodal analysis, I can use MNA to derive the "hard-coded" functions by expanding the MNA to get the nodal analysis equations.  

From NewtonNonlinear.py code, I have changed the F_value from using the hard-coded F(x) function into using the expansion of J(x) with x values substracted by the RHS of the MNA equation. This makes the iteration a bit longer, but the code can now be more generic compared to before. The comparison of solutions using hard-coded function and the more generic method can be seen below.

Hard-coded:
![](circuit_test/Python/hardcoded_nonL.png)

Generic:
![](circuit_test/Python/genericcode_nonL.png)

A tolerance of 1e-9 was chosen as that gives the least iteration for the most accurate value for both the hard-coded and generic methods. This analysis is based from the circuit below which contain a non-linear capacitor, a non-linear resistor, and a voltage source. The circuit is shown below:

![](circuit_test/Python/Nonlinear_circuit.png)

This circuit analysis is based on this research paper which studies regarding MNA, Newton Raphson and Transient simulations, from [Opal, A. (2007) Computer-Aided Design, The Electrical Engineering Handbook. Academic Press.](https://www.sciencedirect.com/science/article/pii/B9780121709600500062)

## 19/10/2022

I have noticed that the expansion of the Jacobian matrix actually needs integration of the variables that we are trying to solve since it was from a derivative of the nodal analysis. This means that the expansion method that was used in NewtonNonlinear.py is not actually accurate even though it can solve for the iteration values. A thorough research on Jacobian matrix, conductance matrix and the nodal analysis function will be done again.

## 21/10/2022

I have managed to utilize the Jacobian matrix and Newton-Raphson iterative method for the non-linear part of the circuit. The circuit that was analysed is the Wheatstone bridge circuit. The arrangement of the circuit in LTSpice can be seen below:

![](circuit_test/Python/WB_circuit.png)

The same circuit with same component values are then simulated in my code by performing the same DC OP analysis. Here, the non-linear analysis using Newton-Raphson was quite convoluted but I have managed to make it work. Since the code must be generic and not hard-coded, the way of doing this is by using the RHS and LHS matrices from before and adding the new diode stamp similar to how the other component stamps were added. However, the catch is that the MNA stamp addition section is also present in the Newton-Raphson algorithm. Most of these algorithms are derived from the [5th Lecture of Circuit analysis and Optimization](https://fides.fe.uni-lj.si/~zigar/CAO/lectures.php). 

Since the Newton-Raphson algorithm is derived from the equation below:

![](circuit_test/Python/NR_eqn.png)

I have changed the way the solution's next iteration will be added which is similar to this equation. The linalg.solve function is used to solve the x in Ax=b since it also uses LU decomposition as intended evaluating sparse matrices. The RHS of the matrix is also added to the F_x matrix that follows the equation below:

![](circuit_test/Python/RHS_matrix_diode.png)

The LHS matrix uses the diode stamp which have the following equation:

![](circuit_test/Python/G_d_diode.png)

By constantly updating the values of the voltages inside the matrix by adding LHS and RHS with their respective new matrices, the Newton-Raphson can then converge on a solution that is accurate. The tolerance in this was chosen to be 1e-9 for high accuracy. The comparison results between the simple_linear.py code and LTSpice wheatstone bridge simulation can be seen below:

simple_linear.py:

![](circuit_test/Python/Nonlinear_result.png)

LTSpice:

![](circuit_test/Python/Nonlinear_test1.png)

It can be seen that the values are really close to each other with only 0.3% to 0.6% error margin that makes it quite accurate. Now, the project focus can be shifted towards using the Newton-Raphson iteration algorithm to solve the dynamic elements to enable transient simulations.





